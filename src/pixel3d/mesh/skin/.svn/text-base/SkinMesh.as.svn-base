package cj7.mesh.skin
{
	import cj7.math.AABBox3D;
	import cj7.math.Matrix4;
	import cj7.math.Quaternion;
	import cj7.math.Vector3D;
	import cj7.math.Vertex;
	import cj7.mesh.IMesh;
	import cj7.mesh.IMeshBuffer;
	import cj7.mesh.animation.AnimatedMeshType;
	import cj7.scene.BoneSceneNode;
	import cj7.scene.SceneManager;
	import cj7.scene.SkinMeshSceneNode;
	public class SkinMesh implements ISkinMesh
	{
		//private
		public var skinningBuffers : Array ;
		public var allJoints : Array ;
		public var rootJoints : Array ;
		
		public var preparedForSkinning : Boolean;
		
		
		public var animationFrames : Number;
		public var lastAnimatedFrame : Number;
		public var lastSkinnedFrame : Number;
		
		
		public var boneControlUsed : Boolean;
		public var animateNormals : Boolean;
		
		
		public var interpolationMode : int;
		
		public var vertices_Moved : Array;
		
		
		//public
		public var hasAnimation : Boolean;
		public var boundingBox : AABBox3D;
		public var name:String;
		
		public function SkinMesh ()
		{
			skinningBuffers = new Array ();
			vertices_Moved = new Array ();
			allJoints = new Array ();
			rootJoints = new Array ();
			
			interpolationMode = 0;
			
			hasAnimation = false;
			preparedForSkinning = false;
			
			animationFrames = 0;
			lastAnimatedFrame = 0;
			lastSkinnedFrame = 0;
			
			boneControlUsed = false;
			animateNormals = false;
			boundingBox=new AABBox3D();
			name='skinned';
		}
		public function getFrameCount () : int
		{
			return Math.floor (animationFrames);
		}
		public function getMesh (frame : int, detailLevel : int = 255, startFrameLoop : int = - 1, endFrameLoop : int = - 1) : IMesh
		{
			if (frame <= - 1) return this;
			if(! hasAnimation) return this;
			animateMesh (frame, 1);
			buildAllLocalAnimatedMatrices ();
			buildAllGlobalAnimatedMatrices (null, null);
			skinMesh ();
			return this;
		}
		//--------------------------------------------------------------------------
		//			Keyframe Animation
		//--------------------------------------------------------------------------
		public function animateMesh (frame : Number, blend : Number) : void
		{
			if (!hasAnimation  || lastAnimatedFrame == frame) return;
			lastAnimatedFrame = frame;
			if (blend <= 0.) return ;//No need to animate
			for (var i : int = 0; i < allJoints.length; i ++)
			{
				//To Bitplane: The joints can be animated here with no input from their parents, but for setAnimationMode extra checks are needed to their parents
				var joint : Joint = allJoints [i];

				var oldPosition : Vector3D = joint.animatedposition;
				var oldScale : Vector3D = joint.animatedscale;
				var oldRotation : Quaternion = joint.animatedrotation;
				
				var position:Vector3D=oldPosition.clone();
				var scale:Vector3D=oldScale.clone();
				var rotation:Quaternion=oldRotation.clone();
				
				if ( ! boneControlUsed)
				{
					joint.positionHint = - 1;
					joint.scaleHint = - 1;
					joint.rotationHint = - 1;
				}
				getFrameData (frame, joint, 
				              position,Math.abs(joint.positionHint), 
				              scale, Math.abs(joint.scaleHint),
				              rotation,Math.abs(joint.rotationHint));
				if (blend == 1.)
				{
					//no blending needed
					joint.animatedposition = position;
					joint.animatedscale = scale;
					joint.animatedrotation = rotation;
				} else
				{
					//blend animation
					var invBlend : Number = (1 - blend);
					joint.animatedposition.x = invBlend * oldPosition.x + position.x * blend;
					joint.animatedposition.y = invBlend * oldPosition.y + position.y * blend;
					joint.animatedposition.z = invBlend * oldPosition.z + position.z * blend;
					joint.animatedscale.x = invBlend * oldScale.x + scale.x * blend;
					joint.animatedscale.y = invBlend * oldScale.y + scale.y * blend;
					joint.animatedscale.z = invBlend * oldScale.z + scale.z * blend;
					joint.animatedrotation.slerp (oldRotation, rotation, blend);
				}

				buildAllLocalAnimatedMatrices ();
			}
			boneControlUsed = false;
		}
		public function buildAllLocalAnimatedMatrices () : void
		{
			for (var i : int = 0; i < allJoints.length; i ++)
			{
				var joint : Joint = allJoints [i];
				//Could be faster:
				if (joint.useAnimationFrom &&
				(joint.useAnimationFrom.positionKeys.length > 0 ||
				joint.useAnimationFrom.scaleKeys.length > 0 ||
				joint.useAnimationFrom.rotationKeys.length > 0 ))
				{
					joint.localAnimatedMatrix.identity ();
					joint.localAnimatedMatrix.setTranslation (joint.animatedposition);
					joint.localAnimatedMatrix.multiplyE (joint.animatedrotation.getMatrix4 (null));
					
					joint.globalSkinningSpace = false;
					if (joint.scaleKeys.length > 0)
					{
						var scaleMatrix : Matrix4 = new Matrix4 ();
						scaleMatrix.setScale (joint.animatedscale);
						joint.localAnimatedMatrix.multiplyE (scaleMatrix);
					}
				} 
				else
				{
					joint.localAnimatedMatrix = joint.localMatrix;
				}
			}
		}
		public function buildAllGlobalAnimatedMatrices (joint : Joint = null, parentJoint : Joint = null) : void
		{
			if ( ! joint)
			{
				for (var i : int = 0; i < rootJoints.length; i ++)
				{
					buildAllGlobalAnimatedMatrices (rootJoints [i] , null);
				}
				return;
			} 
			else
			{
				// Find global matrix...
				if ( ! parentJoint || joint.globalSkinningSpace)
				{
					joint.globalAnimatedMatrix = joint.localAnimatedMatrix;
				}else
				{
					joint.globalAnimatedMatrix = parentJoint.globalAnimatedMatrix.multiply (joint.localAnimatedMatrix);
				}
			}
			for (var j : int = 0; j < joint.children.length; j ++)
			{
				buildAllGlobalAnimatedMatrices (joint.children [j] , joint);
			}
		}
		public function getFrameData (frame : Number, joint : Joint,
		                              position : Vector3D, positionHint : int,
		                              scale : Vector3D, scaleHint : int,
		                              rotation : Quaternion, rotationHint : int) : void
		{
			var foundPositionIndex : int = - 1;
			var foundScaleIndex : int = - 1;
			var foundRotationIndex : int = - 1;
			if (joint.useAnimationFrom)
			{
				var positionKeys : Array = joint.useAnimationFrom.positionKeys;
				var scaleKeys : Array = joint.useAnimationFrom.scaleKeys;
				var rotationKeys : Array = joint.useAnimationFrom.rotationKeys;
				var len:int=positionKeys.length;
				if (len > 0)
				{
					foundPositionIndex = - 1;
					//Test the Hints...
					if (positionHint < len)
					{
						//check this hint
						if (positionKeys [positionHint].frame >= frame && positionKeys [positionHint - 1].frame < frame )
						{
							foundPositionIndex = positionHint;
						} else if (positionHint + 1 < len)
						{
							//check the next index
							if (positionKeys [positionHint + 1].frame >= frame &&
							    positionKeys [positionHint + 0].frame < frame)
							{
								positionHint ++;
								foundPositionIndex = positionHint;
							}
						}
					}
					//The hint test failed, do a full scan...
					if (foundPositionIndex == - 1)
					{
						for (var i : int = 0; i < len; i ++)
						{
							if (positionKeys [i].frame >= frame) //Keys should to be sorted by frame
							
							{
								foundPositionIndex = i;
								positionHint = i;
								break;
							}
						}
					}
					//Do interpolation...
					if (foundPositionIndex != - 1)
					{
						if (interpolationMode == IntepolationMode.CONSTANT || foundPositionIndex == 0)
						{
							position = positionKeys [foundPositionIndex].position;
						} 
						else if (interpolationMode == IntepolationMode.LINEAR)
						{
							var keyA : PositionKey = positionKeys [foundPositionIndex];
							var keyB : PositionKey = positionKeys [foundPositionIndex - 1];
							var fd1 : Number = frame - keyA.frame;
							var fd2 : Number = keyB.frame - frame;
							var posA : Vector3D = keyA.position;
							var posB : Vector3D = keyB.position;
							var k : Number = fd1 / (fd1 + fd2);
							position.x = (posB.x - posA.x) * k + posA.x;
							position.y = (posB.y - posA.y) * k + posA.y;
							position.z = (posB.z - posA.z) * k + posA.z;
						}
					}
				}
				//------------------------------------------------------------
				//scale
				len=scaleKeys.length;
				if (len > 0)
				{
					foundScaleIndex = - 1;
					//Test the Hints...
					if (scaleHint < len)
					{
						//check this hint
						if (scaleKeys [scaleHint].frame >= frame && scaleKeys [scaleHint - 1].frame < frame )
						{
						    foundScaleIndex = scaleHint;
						}
						else if (scaleHint + 1 < len)
						{
							//check the next index
							if (scaleKeys [scaleHint + 1].frame >= frame &&
							    scaleKeys [scaleHint + 0].frame < frame)
							{
								scaleHint ++;
								foundScaleIndex = scaleHint;
							}
						}
					}
					//The hint test failed, do a full scan...
					if (foundScaleIndex == - 1)
					{
						for (i = 0; i < len; i ++)
						{
							if (scaleKeys [i].frame >= frame) //Keys should to be sorted by frame
							{
								foundScaleIndex = i;
								scaleHint = i;
								break;
							}
						}
					}
					//Do interpolation...
					if (foundScaleIndex != - 1)
					{
						if (interpolationMode == IntepolationMode.CONSTANT || foundScaleIndex == 0)
						{
							scale = scaleKeys [foundScaleIndex].scale;
						} 
						else if (interpolationMode == IntepolationMode.LINEAR)
						{
							var keySA : ScaleKey = scaleKeys [foundPositionIndex];
							var keySB : ScaleKey = scaleKeys [foundPositionIndex - 1];
							fd1 = frame - keySA.frame;
							fd2 = keySB.frame - frame;
							posA = keySA.scale;
							posB = keySB.scale;
							k = fd1 / (fd1 + fd2);
							scale.x = (posB.x - posA.x) * k + posA.x;
							scale.y = (posB.y - posA.y) * k + posA.y;
							scale.z = (posB.z - posA.z) * k + posA.z;
						}
					}
				}
				//-------------------------------------------------------------
				//rotation
				len=rotationKeys.length;
				if (len > 0)
				{
					foundRotationIndex = - 1;
					//Test the Hints...
					if (rotationHint < len)
					{
						//check this hint
						if (rotationKeys [rotationHint].frame >= frame && rotationKeys [rotationHint - 1].frame < frame )
						{
						    foundRotationIndex = rotationHint;
						}
						else if (rotationHint + 1 < len)
						{
							//check the next index
							if (rotationKeys [rotationHint + 1].frame >= frame &&
							    rotationKeys [rotationHint + 0].frame < frame)
							{
								rotationHint ++;
								foundRotationIndex = rotationHint;
							}
						}
					}
					//The hint test failed, do a full scan...
					if (foundRotationIndex == - 1)
					{
						for (i = 0; i < len; i ++)
						{
							if (rotationKeys [i].frame >= frame) //Keys should be sorted by frame
							{
								foundRotationIndex = i;
								rotationHint = i;
								break;
							}
						}
					}
					//Do interpolation...
					if (foundRotationIndex != - 1)
					{
						if (interpolationMode == IntepolationMode.CONSTANT || foundRotationIndex == 0)
						{
							rotation = rotationKeys [foundRotationIndex].rotation;
						} 
						else if (interpolationMode == IntepolationMode.LINEAR)
						{
							//rotation.slerp(KeyA.rotation, KeyB.rotation, t);
							var keyRA : RotationKey = rotationKeys [foundPositionIndex];
							var keyRB : RotationKey = rotationKeys [foundPositionIndex - 1];
							fd1 = frame - keyRA.frame;
							fd2 = keyRB.frame - frame;
							var rotationA : Quaternion = keyRA.rotation;
							var rotationB : Quaternion = keyRB.rotation;
							k = fd1 / (fd1 + fd2);
							rotation.slerp (rotationA, rotationB, k);
						}
					}
				}
			}
		}

		// Preforms a software skin on this mesh based of joint positions
		public function skinMesh () : void
		{
			if ( ! hasAnimation) return;

			buildAllGlobalAnimatedMatrices (null, null);
			//-----------------
			//rigid animation
			var len:int=allJoints.length;
			for (var i : int = 0; i < len; i ++)
			{
				var joint:Joint=allJoints [i];
				var len1:int=joint.attachedMeshes.length;
				for (var j : int = 0; j < len1; j ++)
				{
					var buffer : SkinMeshBuffer = joint.attachedMeshes [j];
					buffer.transformation = joint.globalAnimatedMatrix;
				}
			}
			//clear skinning helper array
			len=vertices_Moved.length;
			for (i = 0; i < len; i ++)
			{
				len1=vertices_Moved [i].length;
				for (j = 0; j < len1; j ++)
				{
					vertices_Moved [i][j] = false;
				}
			}
			//skin starting with the root joints
			len=rootJoints.length;
			for (i = 0; i < len; i ++)
			{
				skinJoint (rootJoints [i] , null);
			}
		}
		public function skinJoint (joint : Joint, parentJoint : Joint = null) : void
		{
			if (joint.weights.length > 0)
			{
				//Todo what mean here?
				//Find this joints pull on vertices...
				//core::matrix4 jointVertexPull(core::matrix4::EM4CONST_NOTHING);
				//JointVertexPull.setbyproduct(Joint.GlobalAnimatedMatrix, Joint.GlobalInversedMatrix);
				var jointVertexPull : Matrix4 = joint.globalAnimatedMatrix.multiply (joint.globalInversedMatrix);
				var thisVertexMove : Vector3D = new Vector3D ();
				var thisNormalMove : Vector3D = new Vector3D ();
				var buffersUsed : Array = skinningBuffers;
				//Skin Vertices Positions and Normals...
				for (var i : int = 0; i < joint.weights.length; i ++)
				{
					var weight : Weight = joint.weights [i];
					// Pull this vertex...
					jointVertexPull.transformVector2 (weight.pos, thisVertexMove );
					if (animateNormals)
					{
						jointVertexPull.rotateVector2 (weight.normal, thisNormalMove );
					}
					var usedVertex : Vertex = buffersUsed [weight.bufferID].getVertex (weight.vertexID);
					if ( ! weight.moved)
					{
						weight.moved = true;
						usedVertex.x = thisVertexMove.x * weight.strength;
						usedVertex.y = thisVertexMove.y * weight.strength;
						usedVertex.z = thisVertexMove.z * weight.strength;
						if (animateNormals)
						{
							usedVertex.nx = thisNormalMove.x * weight.strength;
							usedVertex.ny = thisNormalMove.y * weight.strength;
							usedVertex.nz = thisNormalMove.z * weight.strength;
						}
					} 
					else
					{
						usedVertex.x += thisVertexMove.x * weight.strength;
						usedVertex.y += thisVertexMove.y * weight.strength;
						usedVertex.z += thisVertexMove.z * weight.strength;
						if (animateNormals)
						{
							usedVertex.nx += thisNormalMove.x * weight.strength;
							usedVertex.ny += thisNormalMove.y * weight.strength;
							usedVertex.nz += thisNormalMove.z * weight.strength;
						}
					}
				}
			}
			//Skin all children
			var len:int=joint.children.length;
			for (var j : int = 0; j < len; j ++)
			{
				skinJoint (joint.children [j] , joint);
			}
		}

		private function calculateGlobalMatrixes (joint : Joint, parentJoint : Joint) : void
		{
			if ( !joint && parentJoint) return;
			//Go through the root bones
			if ( ! joint)
			{
				var len:int=rootJoints.length;
				for (var i : int = 0; i < len; i ++)
				{
					calculateGlobalMatrixes (rootJoints [i] , null);
				}
				return;
			}
			if ( ! parentJoint)
			{
				joint.globalMatrix = joint.localMatrix;
			} 
			else
			{
				joint.globalMatrix = parentJoint.globalMatrix.multiply (joint.localMatrix);
			}
			joint.localAnimatedMatrix = joint.localMatrix;
			joint.globalAnimatedMatrix = joint.globalMatrix;

			//if (joint.globalInversedMatrix.isIdentity ()) //might be pre calculated
			//{
			//	joint.globalInversedMatrix = joint.globalMatrix;
			//	joint.globalInversedMatrix.makeInverse (); // slow
			//}
			len=joint.children.length;
			for (var j : int = 0; j < len; j ++)
			{
				calculateGlobalMatrixes (joint.children [j] , joint);
			}
		}
		private function checkForAnimation () : void
		{
			var i : int, j : int;
			//Check for animation...
			hasAnimation = false;
			var jointLen : int = allJoints.length;
			for (i = 0; i < jointLen; i ++)
			{
				var joint : Joint = allJoints [i];
				if (joint.useAnimationFrom)
				{
					if (joint.useAnimationFrom.positionKeys.length > 0 ||
					    joint.useAnimationFrom.scaleKeys.length > 0 ||
					    joint.useAnimationFrom.rotationKeys.length > 0 )
					{
						hasAnimation = true;
						break;
					}
				}
			}
			//meshes with weights, are still counted as animated for ragdolls, etc
			if ( ! hasAnimation)
			{
				for (i = 0; i < jointLen; i ++)
				{
					joint = allJoints [i];
					if (joint.weights.length > 0)
					{
						hasAnimation = true;
						break;
					}
				}
			}
			if (hasAnimation)
			{
				//--- Find the length of the animation ---
				//找到最长的帧
				animationFrames = 0;
				for (i = 0; i < jointLen; i ++)
				{
					joint = allJoints [i];
					if (joint.useAnimationFrom)
					{
						var len : int = joint.useAnimationFrom.positionKeys.length;
						if (len > 0)
						{
							var frame : int = joint.useAnimationFrom.positionKeys [len - 1].frame;
							if (frame > animationFrames)
							{
								animationFrames = frame;
							}
						}
						len = joint.useAnimationFrom.scaleKeys.length;
						if (len > 0)
						{
							frame = joint.useAnimationFrom.scaleKeys [len - 1].frame;
							if (frame > animationFrames)
							{
								animationFrames = frame;
							}
						}
						len = joint.useAnimationFrom.rotationKeys.length;
						if (len > 0)
						{
							frame = joint.useAnimationFrom.rotationKeys [len - 1].frame;
							if (frame > animationFrames)
							{
								animationFrames = frame;
							}
						}
					}
				}
			}
			if (hasAnimation && ! preparedForSkinning)
			{
				preparedForSkinning = true;
				//check for bugs:
				for (i = 0; i < jointLen; i ++)
				{
					joint = allJoints [i];
					for (j = 0; j < joint.weights.length; j ++)
					{
						var buffer_id : int = joint.weights [j].buffer_id;
						var vertex_id : int = joint.weights [j].vertex_id;
						//check for invalid ids
						if (buffer_id >= skinningBuffers.length)
						{
							trace ("Skinned Mesh: Weight buffer id too large");
							joint.weights [j].buffer_id = joint.weights [j].vertex_id = 0;
						} 
						else if (vertex_id >= skinningBuffers [buffer_id].getVertexCount ())
						{
							trace ("Skinned Mesh: Weight vertex id too large");
							joint.weights [j].buffer_id = joint.weights [j].vertex_id = 0;
						}
					}
				}
				//An array used in skinning
				for (i = 0; i < vertices_Moved.length; i ++)
				{
					for (j = 0; j < vertices_Moved [i].length; j ++)
					{
						vertices_Moved [i][j] = false;
					}
				}
				// For skinning: cache weight values for speed
				for (i = 0; i < jointLen; i ++)
				{
					joint = allJoints [i];
					for (j = 0; j < joint.weights.length; j ++)
					{
						var weight : Weight = joint.weights [j];
						var vertex : Vertex = skinningBuffers [weight.bufferID].getVertex (weight.vertexID);
						weight.moved = vertices_Moved [weight.bufferID][weight.vertexID];
						weight.pos.x = vertex.x;
						weight.pos.y = vertex.y;
						weight.pos.z = vertex.z;
						weight.normal.x = vertex.nx;
						weight.normal.y = vertex.ny;
						weight.normal.z = vertex.nz;
					}
				}
				// normalize weights
				normalizeWeights ();
			}
		}
		// called by loader after populating with mesh and bone data
		public function finalize () : void
		{
			lastAnimatedFrame = - 1;
			lastSkinnedFrame = - 1;
			//calculate bounding box
			var skinningBuffersLen : int = skinningBuffers.length;
			for (var i : int = 0; i < skinningBuffersLen; i ++)
			{
				skinningBuffers [i].recalculateBoundingBox ();
			}
			// Get BoundingBox...
			if (skinningBuffersLen == 0)
			{
				boundingBox.reset (0, 0, 0);
			}
			else
			{
				var box:AABBox3D=skinningBuffers [0].boundingBox;
				boundingBox.resetBox(box);
				for (var j : int = 1; j < skinningBuffersLen; j ++)
				{
					boundingBox.addBox (skinningBuffers [j].boundingBox);
				}
			}
			//add 5% padding to bounding box
			var padding : Vector3D = boundingBox.getExtent (); //* 0.05;
			padding.x *= 0.05;
			padding.y *= 0.05;
			padding.z *= 0.05;
			boundingBox.minX-=padding.x;
			boundingBox.minY-=padding.y;
			boundingBox.minZ-=padding.z;
			boundingBox.maxX+=padding.x;
			boundingBox.maxY+=padding.y;
			boundingBox.maxZ+=padding.z;
			
			var allJointsLen : int = allJoints.length;
			if (allJointsLen > 0 || rootJoints.length > 0)
			{
				// populate allJoints or RootJoints, depending on which is empty
				if ( ! (rootJoints.length > 0))
				{
					for (var checkingIdx : int = 0; checkingIdx < allJointsLen; checkingIdx ++)
					{
						var foundParent : Boolean = false;
						for (i = 0; i < allJointsLen; i ++)
						{
							for (var n : int = 0; n < allJoints [i].children.length; n ++)
							{
								var joint : Joint = allJoints [i];
								if (joint.children [n] == allJoints [checkingIdx])
								{
									foundParent = true;
								}
							}
						}
						if ( ! foundParent)
						{
							rootJoints.push (allJoints [checkingIdx]);
						}
					}
				} 
				else
				{
					allJoints = rootJoints;
				}
			}
			for (i = 0; i < allJoints.length; i ++)
			{
				allJoints [i].useAnimationFrom = allJoints [i];
			}
			//Set array sizes...
			for (i = 0; i < skinningBuffers.length; i ++)
			{
				vertices_Moved.push (new Array (skinningBuffers [i].getVertexCount ()));
			}
			//Todo: optimise keys here...
			checkForAnimation ();
			if (hasAnimation)
			{
				//--- optimize and check keyframes ---
				for (i = 0; i < allJoints.length; i ++)
				{
					var positionKeys : Array = allJoints [i].positionKeys;
					var scaleKeys : Array = allJoints [i].scaleKeys;
					var rotationKeys : Array = allJoints [i].rotationKeys;
					if (positionKeys.length > 2)
					{
						for (j = 0; j < positionKeys.length - 2; j ++)
						{
							var p0 : Vector3D = positionKeys [j].position;
							var p1 : Vector3D = positionKeys [j + 1].position;
							var p2 : Vector3D = positionKeys [j + 2].position;
							if (p0.equals (p1) && p1.equals (p2))
							{
								positionKeys.splice (j + 1, 1)
								//the middle key is unneeded
								j --;
							}
						}
					}
					if (positionKeys.length > 1)
					{
						for (j = 0; j < positionKeys.length - 1; j ++)
						{
							if (positionKeys [j].frame >= positionKeys [j + 1].frame) //bad frame, unneed and may cause problems
							{
								positionKeys.splice (j + 1, 1);
								j --;
							}
						}
					}
					if (scaleKeys.length > 2)
					{
						for (j = 0; j < scaleKeys.length - 2; j ++)
						{
							p0 = scaleKeys [j].scale;
							p1 = scaleKeys [j + 1].scale;
							p2 = scaleKeys [j + 2].scale;
							if (p0.equals (p1) && p1.equals (p2))
							{
								scaleKeys.splice (j + 1, 1);
								//the middle key is unneeded
								j --;
							}
						}
					}
					if (scaleKeys.length > 1)
					{
						for (j = 0; j < scaleKeys.length - 1; j ++)
						{
							if (scaleKeys [j].frame >= scaleKeys [j + 1].frame) //bad frame, unneed and may cause problems
							{
								scaleKeys.splice (j + 1, 1);
								j --;
							}
						}
					}
					if (rotationKeys.length > 2)
					{
						for (j = 0; j < rotationKeys.length - 2; j ++)
						{
							var r0 : Quaternion = rotationKeys [j].rotation;
							var r1 : Quaternion = rotationKeys [j + 1].rotation;
							var r2 : Quaternion = rotationKeys [j + 2].rotation;
							if (r0.equals (r1) && r1.equals (r2))
							{
								rotationKeys.splice (j + 1, 1);
								j --;
							}
						}
					}
					if (rotationKeys.length > 1)
					{
						for (j = 0; j < rotationKeys.length - 1; j ++)
						{
							if (rotationKeys [j].frame >= rotationKeys [j + 1].frame) //bad frame, unneed and may cause problems
							{
								rotationKeys.splice (j + 1, 1);
								j --;
							}
						}
					}
					//Fill empty keyframe areas
					if (positionKeys.length > 0)
					{
						//getFirst,使其首帧为0
						if (positionKeys [0].frame != 0)
						{
							positionKeys.unshift (new PositionKey ());
							positionKeys [0].frame = 0;
							positionKeys [0].position = positionKeys [1].position.clone ();
						}
						//getLast
						if (positionKeys [positionKeys.length - 1].frame != animationFrames)
						{
							positionKeys.push (new PositionKey ());
							positionKeys [positionKeys.length - 1].frame = animationFrames;
							positionKeys [positionKeys.length - 1].position = positionKeys [positionKeys.length - 2].position.clone ();
						}
					}
					if (scaleKeys.length > 0)
					{
						//getFirst,使其首帧为0
						if (scaleKeys [0].frame != 0)
						{
							scaleKeys.unshift (new ScaleKey ());
							scaleKeys [0].frame = 0;
							scaleKeys [0].scale = scaleKeys [1].scale.clone ();
						}
						//getLast
						if (scaleKeys [scaleKeys.length - 1].frame != animationFrames)
						{
							scaleKeys.push (new ScaleKey ());
							scaleKeys [scaleKeys.length - 1].frame = animationFrames;
							scaleKeys [scaleKeys.length - 1].scale = scaleKeys [scaleKeys.length - 2].scale.clone ();
						}
					}
					if (rotationKeys.length > 0)
					{
						//getFirst,使其首帧为0
						if (rotationKeys [0].frame != 0)
						{
							rotationKeys.unshift (new RotationKey ());
							rotationKeys [0].frame = 0;
							rotationKeys [0].rotation = rotationKeys [1].rotation.clone ();
						}
						//getLast
						if (rotationKeys [rotationKeys.length - 1].frame != animationFrames)
						{
							rotationKeys.push (new RotationKey ());
							rotationKeys [rotationKeys.length - 1].frame = animationFrames;
							rotationKeys [rotationKeys.length - 1].rotation = rotationKeys [rotationKeys.length - 2].rotation.clone ();
						}
					}
				}
			}
			//Needed for animation and skinning...
			calculateGlobalMatrixes (null, null);
			//animateMesh(0, 1);
			//buildAll_LocalAnimatedMatrices();
			//buildAll_GlobalAnimatedMatrices();
			//rigid animation for non animated meshes
			for (i = 0; i < allJoints.length; i ++)
			{
				for (j = 0; j < allJoints [i].attachedMeshes.length; j ++)
				{
					var buffer : SkinMeshBuffer = allJoints [i].attachedMeshes [j];
					buffer.transformation = allJoints [i].globalAnimatedMatrix;
				}
			}
		}
		
		public function getMeshType () : int
		{
			return AnimatedMeshType.AMT_SKINNED;
		}
		// Gets joint count.
		public function getJointCount () : int
		{
			return allJoints.length;
		}
		// Gets the name of a joint.
		public function getJointName (num : int) : String
		{
			if (num < 0 || num >= allJoints.length) return null;
			return allJoints [num].name;
		}
		// Gets a joint number from its name
		public function getJointIndex (name : String) : int
		{
			for (var i : int = 0; i < allJoints.length; i ++)
			{
				if (allJoints [i].name == name) return i;
			}
			return - 1;
		}
		// returns amount of mesh buffers.
		public function getMeshBufferCount () : int
		{
			return skinningBuffers.length;
		}
		// returns pointer to a mesh buffer
		public function getMeshBuffer (nr : int) : IMeshBuffer
		{
			if (nr < 0 || nr >= skinningBuffers.length) return null;

			return skinningBuffers [nr];	
		}
		// returns an axis aligned bounding box
		public function getBoundingBox () : AABBox3D
		{
			return boundingBox;
		}
		// set user axis aligned bounding box
		public function setBoundingBox (box : AABBox3D) : void
		{
			this.boundingBox = box;
		}
		// sets a flag of all contained materials to a new value
		public function setMaterialFlag (flag : int, value : Boolean) : void
		{
			for (var i : int = 0; i < skinningBuffers.length; i ++)
			{
				var buffer:SkinMeshBuffer=skinningBuffers [i];
				buffer.material.setFlag (flag, value);
			}
		}
		// uses animation from another mesh
		public function useAnimationFrom (mesh : ISkinMesh) : Boolean
		{
			var unmatched : Boolean = false;
			for (var i : int = 0; i < allJoints.length; i ++)
			{
				var joint : Joint = allJoints [i];
				joint.useAnimationFrom = null;
				if (joint.name == "")
				{
					unmatched = true;
				} else
				{
					for (var j : int = 0; j < mesh.getAllJoints ().length; j ++)
					{
						var otherJoint : Joint = mesh.getAllJoints ()[j];
						if (joint.name == otherJoint.name)
						{
							joint.useAnimationFrom = otherJoint;
						}
					}
					if ( ! joint.useAnimationFrom) unmatched = true;
				}
			}
			checkForAnimation ();
			return ! unmatched;
		}
		//Update Normals when Animating
		public function updateNormalsWhenAnimating (on : Boolean=false) : void
		{
			animateNormals = on;
		}
		//Sets Interpolation Mode
		public function setInterpolationMode (mode : int) : void
		{
			interpolationMode = mode;
		}
		public function getMeshBuffers () : Array
		{
			return skinningBuffers;
		}
		public function getAllJoints () : Array
		{
			return allJoints;
		}

		

		public function createBuffer () : SkinMeshBuffer
		{
			var buffer : SkinMeshBuffer = new SkinMeshBuffer ();
			skinningBuffers.push (buffer);
			return buffer;
		}
		public function createJoint (parent : Joint = null) : Joint
		{
			var joint : Joint = new Joint ();
			allJoints.push (joint);
			if ( ! parent)
			{
				//Add root joints to array in finalize()
				
			} 
			else
			{
				//Set parent (Be careful of the mesh loader also setting the parent)
				parent.children.push (joint);
			}
			return joint;
		}
		public function createPositionKey (joint : Joint) : PositionKey
		{
			if ( ! joint) return null;
			var key : PositionKey = new PositionKey ();
			key.frame = 0;
			joint.positionKeys.push (key);
			return key;
		}
		public function createScaleKey (joint : Joint) : ScaleKey
		{
			if ( ! joint) return null;
			var key : ScaleKey = new ScaleKey ();
			key.frame = 0;
			joint.scaleKeys.push (key);
			return key;
		}
		public function createRotationKey (joint : Joint) : RotationKey
		{
			if ( ! joint) return null;
			var key : RotationKey = new RotationKey ();
			key.frame = 0;
			joint.rotationKeys.push (key);
			return key;
		}
		public function createWeight (joint : Joint) : Weight
		{
			if ( ! joint) return null;
			var weight : Weight = new Weight ();
			joint.weights.push (weight);
			//Could do stuff here...
			return weight;
		}
		public function normalizeWeights () : void
		{
			// note: unsure if weights ids are going to be used.
			// Normalise the weights on bones....
			var i : int, j : int;
			var vertices_TotalWeight : Array = [];
			
			for (i = 0; i < skinningBuffers.length; i ++)
			{
				var count : int = skinningBuffers [i].getVertexCount ();
				vertices_TotalWeight.push (new Array (count));
			}
			var len0:int=vertices_TotalWeight.length;
			for (i = 0; i < len0; i ++)
			{
				var len1:int=vertices_TotalWeight [i].length;
				for (j = 0; j < len1; j ++)
				{
					vertices_TotalWeight [i][j] = 0;
				}
			}
			var jointLen : int = allJoints.length;
			for (i = 0; i < jointLen; i ++)
			{
				var joint : Joint = allJoints [i];
				len0=joint.weights.length
				for (j = 0; j < len0; j ++)
				{
					var weight : Weight = joint.weights [j];
					if (weight.strength <= 0) //Check for invalid weights
					{
						joint.weights.splice (j, 1);
						j --;
					} 
					else
					{
						vertices_TotalWeight [weight.bufferID ][weight.vertexID ] += weight.strength;
					}
				}
			}
			for (i = 0; i < jointLen; i ++)
			{
				joint = allJoints [i];
				for (j = 0; j < joint.weights.length; j ++)
				{
					weight = joint.weights [j];
					var total : Number = vertices_TotalWeight [weight.bufferID ][weight.vertexID ];
					if (total != 0 && total != 1)
					weight.strength /= total;
				}
			}
		}
		public function recoverJointsFromMesh (jointChildSceneNodes : Array) : void
		{
			for (var i : int = 0; i < allJoints.length; i ++)
			{
				var node : BoneSceneNode = jointChildSceneNodes [i];
				var joint : Joint = allJoints [i];
				node.setPosition (joint.localAnimatedMatrix.getTranslation ());
				node.setRotation (joint.localAnimatedMatrix.getRotationDegrees ());
				//node.setScale( joint.localAnimatedMatrix.getScale() );
				node.positionHint = joint.positionHint;
				node.scaleHint = joint.scaleHint;
				node.rotationHint = joint.rotationHint;
				//node.setAbsoluteTransformation(joint.GlobalMatrix); //not going to work
				//Note: This updateAbsolutePosition will not work well if joints are not nested like b3d
				//node.updateAbsolutePosition();
			}
		}
		public function transferJointsToMesh (jointChildSceneNodes : Array) : void //<BoneSceneNode>
		
		{
			for (var i : int = 0; i < allJoints.length; i ++)
			{
				var node : BoneSceneNode = jointChildSceneNodes [i];
				var joint : Joint = allJoints [i];
				joint.localAnimatedMatrix.setTranslation (node.getPosition ());
				joint.localAnimatedMatrix.setRotationDegrees (node.getRotation ());
				//joint.localAnimatedMatrix.setScale( node.getScale() );
				joint.positionHint = node.positionHint;
				joint.scaleHint = node.scaleHint;
				joint.rotationHint = node.rotationHint;
				if (node.getSkinningSpace () == 0) //EBSS_GLOBAL)
				{
					joint.globalSkinningSpace = true;
				} 
				else
				{
					joint.globalSkinningSpace = false;
				}
			}
			//Remove cache, temp...
			lastAnimatedFrame = - 1;
			lastSkinnedFrame = - 1;
			boneControlUsed = true;
		}
		public function createJoints (nodes : Array, skinMeshSceneNode : SkinMeshSceneNode, sceneManager : SceneManager) : void
		{
			//Create new joints
			for (var i : int = 0; i < allJoints.length; i ++)
			{
				var joint:Joint=allJoints [i];
				var node : BoneSceneNode = new BoneSceneNode (sceneManager,i, joint.name);
				sceneManager.addChild(node);
				nodes.push (node);
			}
			//Match up parents
			for (i = 0; i < nodes.length; i ++)
			{
				node = nodes [i];
				joint = allJoints [i];
				var parentID : int = - 1;
				for (var j : int = 0; j < allJoints.length; j ++)
				{
					if (i != j && parentID == - 1)
					{
						var parentTest : Joint = allJoints [j];
						for (var n : int = 0; n < parentTest.children.length; n ++)
						{
							if (parentTest.children [n] == joint)
							{
								parentID = j;
								break;
							}
						}
					}
				}
				if (parentID != - 1)
				node.parent= nodes [parentID];
				else
				node.parent= skinMeshSceneNode;
			}
		}
		public function getTriangleCount () : int
		{
			var triangleCount : int;
			for (var i : int = 0; i < skinningBuffers.length; i ++)
			{
				var buffer :SkinMeshBuffer = skinningBuffers [i]
				triangleCount += buffer.getTriangleCount ();
			}
			return triangleCount;
		}
		public function toString():String
		{
			return name;
		}
		public function appendMesh(m:IMesh):void
		{
		}
		public function getName():String
		{
			return name;
		}
		public function recalculateBoundingBox () : void
		{
		}
	}
}
